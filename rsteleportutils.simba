{$INCLUDE_ONCE SRL-T/osr.simba}

type
  ETeleportType = (
    NORMAL_MAGIC,
    ANCIENT_MAGICKS,
    LUNAR_MAGIC,
    ARCEUUS_MAGIC,
    JEWELLERY,
    OTHER,
    SCROLL,
    FAIRY_RING
  );

  TTeleportLocation = record
    worldPoint: TPoint;
    teleportType: ETeleportType;
    magicLevel: Int32;
    item: String;
    destination: String;
    teleportTab: String;
  end;

  TTeleportJewellery = record
    unchargedID: Int32;
    chargedIDs: TIntegerArray;
    unchargedName: TRSItem;
    chargedNames: TRSItemArray;
  end;

function setupTeleportJewellery(unchargedName: TRSItem; chargedName: TRSItem): TTeleportJewellery;
begin
  result.unchargedName := unchargedName;
  result.chargedNames := chargedName.GetArray();
end;

function setupTeleportLocation(teleportType: ETeleportType; destination: String; level: Int32; worldPoint: TPoint): TTeleportLocation;
begin
  result.worldPoint := worldPoint;
  result.destination := destination;
  result.magicLevel := level;
  result.teleportType := teleportType;
end;

function setupTeleportLocation(teleportType: ETeleportType; item, destination: String; worldPoint: TPoint): TTeleportLocation; overload;
begin
  result.worldPoint := worldPoint;
  result.destination := destination;
  result.item := item;
  result.teleportType := teleportType;
end;

procedure QuickSortTele(var AI: array of TTeleportLocation; ALo, AHi: Integer; closestPoint: TPoint);
var
  Lo, Hi: Integer;
  Pivot: Double;
  T: TTeleportLocation;
begin
  Lo := ALo;
  Hi := AHi;
  Pivot := AI[(Lo + Hi) div 2].worldPoint.DistanceTo(closestPoint);
  repeat
    while AI[Lo].worldPoint.DistanceTo(closestPoint) < Pivot do
      Inc(Lo) ;
    while AI[Hi].worldPoint.DistanceTo(closestPoint) > Pivot do
      Dec(Hi) ;
    if Lo <= Hi then
    begin
      T := AI[Lo];
      AI[Lo] := AI[Hi];
      AI[Hi] := T;
      Inc(Lo) ;
      Dec(Hi) ;
    end;
  until Lo > Hi;
  if Hi > ALo then
    QuickSortTele(AI, ALo, Hi, closestPoint) ;
  if Lo < AHi then
    QuickSortTele(AI, Lo, AHi, closestPoint) ;
end;

function getTeleportJewellery(): array of TTeleportJewellery;
begin
  Result := [
    setupTeleportJewellery('amulet of glory', 'amulet of glory(1..6)'),
    setupTeleportJewellery('ring of wealth', 'ring of wealth (1..5)'),
    setupTeleportJewellery('skills necklace', 'skills necklace(1..6)'),
    setupTeleportJewellery('combat bracelet', 'combat bracelet(1..6)'),
    setupTeleportJewellery('ring of dueling', 'ring of dueling(1..8)'),
    setupTeleportJewellery('slayer ring', 'slayer ring (1..8)'),
    setupTeleportJewellery('digsite pendant', 'digsite pendant (1..5)'),
    setupTeleportJewellery('necklace of passage', 'necklace of passage(1..5)'),
    setupTeleportJewellery('games necklace', 'games necklace(1..8)')
  ];
end;

function getChargedJewelleryNames(unchargedName: String): TRSItemArray;
var
  jewellery: TTeleportJewellery;
begin
  for jewellery in getTeleportJewellery() do
  begin
    if jewellery.unchargedName = unchargedName.Lower() then
      Exit(jewellery.chargedNames);
  end
end;

function sortTeleportsByDistance(closestPoint: TPoint; teleports: array of TTeleportLocation): array of TTeleportLocation;
//var
//  I: Int32;
begin
  QuickSortTele(teleports, Low(teleports), High(teleports), closestPoint);
//
//  for I := Low(teleports) to High(teleports) do
//    Writeln('teleports(',I + 1,') = ', teleports[I]);

  Exit(teleports);
end;


